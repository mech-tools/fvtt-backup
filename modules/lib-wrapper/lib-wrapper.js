const e={base:Error,internal:Error,package:Error,already_overridden:Error,invalid_chain:Error};Object.seal(e);const t="lib-wrapper";let r=!1;const i=function(e,t,r,i=!0){if(Object.isFrozen(e))throw new Error(`libWrapper: Enum '${e.name}' is frozen.`);if(t!==t.toUpperCase())throw new Error("libWrapper: Enum keys must be all uppercase.");const n=new(Function("x",`return class ${t} extends x {}`)(e.value_cls));if(n.name!=t)throw new Error(`libWrapper: Incorrect value_obj name ${n.name}. Expected ${t}.`);if(void 0!==r&&(n.value=r),Object.freeze(n),Object.freeze(n.prototype),Object.freeze(n.constructor),Object.freeze(n.constructor.prototype),t in e)throw new Error(`libWrapper: Name '${t}' is already present in ${e.name}.`);if(e[t]=n,void 0!==r){if(e.reverse.has(r))throw new Error(`libWrapper: Value '${r}' is already present in ${e.name}.`);e.reverse.set(r,n)}return e.list.push(n),i&&e.sort_list_by_value(),n},n=function(e,t,r=!0){let n;if("string"!=typeof e)throw new Error("libWrapper: Enum name must be a string");if("object"!=typeof t)throw new Error("libWrapper: Enum collection must be a dictionary or an array");const a=!(t instanceof Array),s=`${e}Enum`,o={[s]:class{constructor(e,t){return this.constructor.get(e,t)}static get(t,r){if(t instanceof n)return t;if("string"==typeof t){const e=this[t.toUpperCase()];if(e)return e}{const e=this.reverse.get(t);if(void 0!==e)return e}if(void 0===r)throw new Error(`libWrapper: '${t}' is not a valid key or value for the enum ${e}.`);return r}static has(e){return e instanceof n}static toString(){return this.name}static get value_cls(){return n}static sort_list_by_value(){return this.list.sort((function(e,t){return(e.value??0)-(t.value??0)}))}}}[s],c=`${e}Value`;if(n={[c]:class{static toString(){return c}get name(){return this.constructor.name}get enum(){return o}toString(){return this.name}get lower(){return this.name.toLowerCase()}}}[c],Object.freeze(n),Object.freeze(n.prototype),o.list=[],a&&(o.reverse=new Map),t instanceof Array)for(const e of t)i(o,e,void 0,!1);else for(const e in t)i(o,e,t[e],!1);return o.sort_list_by_value(),r&&(Object.freeze(o),Object.freeze(o.prototype),Object.freeze(o.list),a&&Object.freeze(o.reverse)),o};var a={"lib-wrapper":{settings:{yes:"Yes",no:"No",save:"Save",reload:"Reload",reset:"Reset","notify-issues-gm":{name:"Notify GM of Issues",hint:"Whether to notify GMs when an issue is detected, for example a conflict."},"notify-issues-player":{name:"Notify Players of Issues",hint:"Whether to notify Players when an issue is detected, for example a conflict."},"high-performance-mode":{name:"High-Performance Mode",hint:"This disables most dynamic conflict detection capabilities in exchange for performance, especially relevant on low-end systems. Note that this will significantly decrease the chance conflicts are detected. As such, it is recommended to turn this off when installing or updating packages."},menu:{title:"libWrapper Settings Menu",priorities:{name:"Priorities","package-inactive":"Inactive","statistics-disabled":"Note: Statistics collection is disabled, not able to show unprioritized packages.",prioritized:{title:"Prioritized Packages",hint:"These packages will be prioritized compared to any package not in this list.\nHigher positions in the list result in a higher priority."},unprioritized:{title:"Unprioritized Packages",hint:"These packages will be neither prioritized nor deprioritized.\nPriorities among these packages are decided on a first-come-first-served basis.\nNew packages will default to this list."},deprioritized:{title:"Deprioritized Packages",hint:"These packages will be deprioritized compared to any package not in this list.\nHigher positions in the list result in a higher priority.",note:"Note that packages that do not use libWrapper are deprioritized even compared to these."}},conflicts:{name:"Conflicts","none-detected":"No conflicts have been detected.","statistics-disabled":"Statistics collection is disabled.","show-ignored":"Show ignored conflicts"},"active-wrappers":{name:"Active Wrappers","none-active":"No wrappers are active right now."},about:{name:"About","full-name":"About libWrapper",credits:"{name} {version} by {author}.","credits-translation":"",description:"'libWrapper' is a library which provides package developers with a simple way to modify core Foundry VTT code, while reducing the likelihood of conflict with other packages.",info:'You can find more information about this module in the <a href="{repo_url}">Foundry VTT package repository</a>, as well as the project\'s <a href="{github_url}">Github page</a>.',support:"<b>If you encounter any issues</b>, the easiest way to find support is to ask the community. The largest community-provided support channels are:","issue-tracker":'If you encounter an <b>internal libWrapper error</b>, or are a <b>package developer</b>, you may also submit a support request in the <a href="{issues_url}">libWrapper Github Issue Tracker</a>.'},"warning-reset-priorities":"Resetting the package priorities will move all packages back to 'Unprioritized'. This action cannot be undone. Are you sure you want to continue?","warning-save":"It is recommended you reload this page to apply the new package priorities. Do you wish to reload?"}},packages:{"unknown-title":"Unknown","type-plus-id":"{type} {id}","type-plus-title":"{type} {title}",types:{module:"module",system:"system",world:"world script",unknown:"package"}},error:{"see-js-console":"(See JS Console)","tech-details":"== Technical Details:","community-support":"Ask the community for support:","not-lw":"This is *not* a libWrapper bug.",external:{notification:"{title}: Error detected in {type}.",message:"Error detected in {type} {title}.",info:"Find information about this {type} here: {url}",report:"Report this issue here: {url}","likely-not-updated":"It is likely this {type} has not been updated for FVTT {version}."},internal:{message:"Internal error detected.","message-with-package":"Internal error detected, involving {type} {title}.",info:"Find information about libWrapper here: {url}",report:"Report this issue here: {url}"},conflict:{potential:"Potential conflict detected between {main} and {other}.",confirmed:"Conflict detected between {main} and {other}.",info:"Find information about these packages here:",report:"Report this conflict here:"}},"support-channels":[{title:"FoundryVTT Discord's #modules-troubleshooting channel",url:"https://discord.gg/foundryvtt"},{title:"FoundryVTT Reddit",url:"https://www.reddit.com/r/FoundryVTT"}]}};const s=["en","es","pt-BR","pt-PT"],o=import.meta?.url?.endsWith("dist/lib-wrapper.js")?"../lang":"./lang";class c{static async _fetch(e){if(Array.isArray(s)&&!s.includes(e))return null;try{const t=new URL(`${o}/${e}.json`,import.meta.url),r=await fetch(t);return 200===r.status&&r.ok?r.json():null}catch(e){return console.warn(`libWrapper: Failed to load or parse ${url.href}.`,e),null}}static async init(){this.jsons=[];const e=[];try{const t=localStorage?.["core.language"];if(t){const r=JSON.parse(t);r&&"en"!==r&&e.push(r)}}catch(e){console.debug("libWrapper: Could not find or parse client language settings.")}const t=game?.i18n?.lang;if(t&&"en"!==t&&e.push(t),e.length>0){const t=await Promise.all(e.map((e=>this._fetch(e))));for(const e of t)e&&this.jsons.push(e)}}static localize(e){if(game?.i18n){const t=game.i18n.localize(e);if(t!==e)return t}try{const t=e.split(".");if(this.jsons)for(const e of this.jsons){const r=t.reduce(((e,t)=>e?.[t]),e);if(r)return r}return t.reduce(((e,t)=>e?.[t]),a)??e}catch(t){return console.error(t),e}}static format(e,t){if(game?.i18n){const r=game.i18n.format(e,t);if(r!==e)return r}const r=this.localize(e);if(r===e)return r;try{return r.replace(/\{(.*?)\}/g,((e,r)=>t?.[r]))}catch(t){return console.error(t),e}}}const l=function(t=!1){const r=game?.user?.data;if(r)return r;const i=game.userId??game.data.userId;if(!i){if(t)return null;throw new e.internal("Unable to obtain the current user ID")}const n=game.data.users.find((e=>e._id==i));if(!n){if(t)return null;throw new e.internal("Unable to obtain the current user data object")}return n},p=n("PackageType",["UNKNOWN","MODULE","SYSTEM","WORLD"]),d=[":","~"],u=new RegExp("^[a-z0-9_-]+$","i"),h=/^.*?\/(worlds|systems|modules)\/(.+?)(?=\/).*?$/gim;const g=function(e,t,r){if(void 0===t){const e=Error.stackTraceLimit;try{Error.stackTraceLimit=1/0,t=Error().stack}finally{Error.stackTraceLimit=e}}if(!t||"string"!=typeof t)throw new Error("libWrapper: Could not collect stack trace.");const i=t.matchAll(h);if(i){for(const t of i){const i=t[1],n=t[2];if(!i||!n)continue;let a,s;if("worlds"===i){const e=game?.data?.world?.id;if(e&&n!=e)continue;a=n,s=p.WORLD}else if("systems"===i){const e=game?.data?.system?.id;if(e&&n!=e)continue;a=n,s=p.SYSTEM}else{if("modules"!==i)throw new Error(`libWrapper: Invalid script type: ${i}`);if(game?.modules&&!game.modules.has(n))continue;if(r&&(n===r||r?.includes?.(n)))continue;a=n,s=p.MODULE}if(!1===e(a,s,t[0]))return!1}return!0}};class f{static get UNKNOWN(){return new f("Â«unknownÂ»",p.UNKNOWN)}static collect_all(e,t,r){const i=new Set;g(((e,r,n)=>{const a=`${r.lower}:${e}`;return!!i.has(a)||(void 0!==t&&!t(e,r,n)||(i.add(a),!0))}),e,r);const n=[];for(const e of i)n.push(new f(e));return n}static is_valid_id(e){return!(!e||"string"!=typeof e)&&!!u.test(e)}constructor(e=null,t=null){this.set(e,t)}set(e=null,t=null,r=!0){if(!e)return this.detect_id();if("string"!=typeof e)throw new Error("libWrapper: PackageInfo IDs must be strings");if("Â«unknownÂ»"!==e){if(null!==t||!this.from_key(e,!1)){if(!this.constructor.is_valid_id(e))throw new Error(`libWrapper: Invalid package ID '${e}'`);if(null!==t&&!p.has(t))throw new Error(`libWrapper: Package type for '${e}' must belong to the PACKAGE_TYPES enum, but got '${t}'.`);this.id=e,this.type=t,t||this.detect_type(),r&&Object.freeze(this)}}else this.set_unknown()}set_unknown(){this.id="Â«unknownÂ»",this.type=p.UNKNOWN}equals(e){return e&&e.constructor===this.constructor&&e.id===this.id&&e.type===this.type}detect_id(e){this.set_unknown(),g(((e,t)=>(this.set(e,t),!1)),e,"lib-wrapper")}detect_type(){game?.modules?game.modules?.get(this.id)?.active?this.type=p.MODULE:this.id===game.data?.system?.id?this.type=p.SYSTEM:this.id===game.data?.world?.id?this.type=p.WORLD:this.type=p.UNKNOWN:this.id===t?this.type=p.MODULE:this.type=p.UNKNOWN}from_key(e,t=!0){let r;for(const t of d)if(r=e.split(t),2===r.length)break;if(2!==r.length){if(t)throw new Error(`libWrapper: Invalid key '${e}'`);return!1}const i=r[1],n=p[r[0]];return this.set(i,n),!0}toString(){return this.key}get known(){return this.type!=p.UNKNOWN}get exists(){switch(this.type){case p.MODULE:return game.modules.get(this.id)?.active;case p.SYSTEM:return game.data.system.id===this.id;case p.WORLD:return game.data.world.id===this.id;default:return!1}}get data(){if(!this.exists)return null;switch(this.type){case p.MODULE:return game.modules.get(this.id)?.data;case p.SYSTEM:return game.data.system.data;case p.WORLD:return game.data.world;default:return null}}static get unknown_title(){return c.localize("lib-wrapper.packages.unknown-title")}get title(){if(!this.exists)return this.constructor.unknown_title;switch(this.type){case p.MODULE:case p.SYSTEM:case p.WORLD:return this.data.title;default:return this.constructor.unknown_title}}get key(){return`${this.type.lower}:${this.id}`}get type_i18n(){return c.localize(`lib-wrapper.packages.types.${this.type.lower}`)}get type_plus_id(){return`${this.type.lower} ${this.id}`}get type_plus_id_capitalized(){let e=this.type_plus_id;return e.charAt(0).toUpperCase()+e.slice(1)}get type_plus_id_i18n(){return c.format("lib-wrapper.packages.type-plus-id",{type:this.type_i18n,id:this.id})}get type_plus_title(){return`${this.type.lower} ${this.title}`}get type_plus_title_i18n(){return c.format("lib-wrapper.packages.type-plus-title",{type:this.type_i18n,title:this.title})}get logId(){return this.type==p.MODULE?this.id:this.key}get settingsName(){switch(this.type){case p.MODULE:return this.id;case p.SYSTEM:return`${this.id} [System]`;case p.WORLD:return`${this.id} [World]`;default:return this.id}}get url(){return this.data?.url}get bugs(){return this.data?.bugs}get version(){return this.data?.version}get core_version_range(){const e=this.data;return e?[e.minimumCoreVersion,e.compatibleCoreVersion]:null}get compatible_with_core(){const t=this.core_version_range,r=function(t=!0){const r=game?.version??game?.release?.version??game?.data?.version??null;if(!t&&null===r)throw new e.internal("Unable to obtain the Foundry version");return r}(!0);if(!t||!r)return!0;const[i,n]=t;return!(i&&i!==r&&!isNewerVersion(r,i))&&(!n||!isNewerVersion(r,n))}}Object.freeze(f);const _=eval;function w(e,t){try{e.displayName=t,Object.defineProperty(e,"name",{value:t,writable:!1,enumerable:!1,configurable:!0})}catch(e){}}function m(e,t=""){return""!==t?`ðŸŽ${e}#${t}`:`ðŸŽ${e}`}function y(e){const t=Object.getOwnPropertyNames(e);t.push(...Object.getOwnPropertySymbols(e));for(const r of t){const t=Object.getOwnPropertyDescriptor(e,r);"function"==typeof t.value&&w(t.value,m(r)),"function"==typeof t.get&&w(t.get,m(r,"getter")),"function"==typeof t.set&&w(t.set,m(r,"setter"))}e.prototype&&y(e.prototype)}const b=new Set;function k(e){return null!=e&&"object"==typeof e&&("message"in e&&"stack"in e)}const v=["/listeners.js",m("call_wrapped"),m("Application.prototype._render")];function E(e,r){const i=function(e,r){return f.collect_all(e,((e,r,i)=>{if(e!==t||r!==p.MODULE)return!0;for(const e of v)if(i.includes(e))return!1;return!0}),r)}(e,r),n=i.length;return n<=0?"[No packages detected]":1==n?`[Detected 1 package: ${i[0].logId}]`:`[Detected ${n} packages: ${i.map((e=>e.logId)).join(", ")}]`}function O(e,t){if(!(t in e))return!1;const r=Object.getOwnPropertyDescriptor(e,t);if(r){if(!("value"in r))return!1;if("string"!=typeof r.value)return!1;if(!r.writable)return!1}else{if("string"!=typeof e[t])return!1}return!0}function W(e,t){if(!k(e))return;if(e.skip_package_detection)return;if(!function(e){return!Object.isFrozen(e)&&!(!O(e,"message")||!O(e,"stack"))}(e))return;const r=E(e.stack,t);if(e.message.endsWith(r))return void(e.skip_package_detection=!0);const i=e.message;e.message+=`\n${r}`,e.stack=e.stack.replace(i,e.message),e.skip_package_detection=!0}class z extends Error{get notification_fn(){return"error"}constructor(e,r,...i){super(r,...i),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.ui_msg=e,this.console_msg=r,W(this,this instanceof A?null:t)}onUnhandled(){}}Object.freeze(z),e.base=z;class A extends z{static construct_message(e,t){const r="lib-wrapper.error",i=`${r}.internal`,n=t.known?c.format(`${type.prefix}.message-with-package`,{type:t.type_i18n,title:t.title}):c.localize(`${i}.message`);return[`libWrapper: ${n}`,`${n}\n\n${c.format(`${i}.info`,{url:"https://github.com/ruipin/fvtt-lib-wrapper"})}\n${c.format(`${i}.report`,{url:"https://github.com/ruipin/fvtt-lib-wrapper/issues"})}\n\n${c.localize(`${r}.tech-details`)}\nInternal libWrapper error.\n${t.known?`Related Package ID= ${t.logId}\n`:""}Error= ${e}\n`]}constructor(e,...t){const r=new f,[i,n]=A.construct_message(e,r);super(i,n,...t),this.package_info=r}get package_id(){return this.package_info?.id}}Object.freeze(A),e.internal=A;class T extends z{static get_community_support_message(){const e=[],t=c.localize("lib-wrapper.support-channels");if(Array.isArray(t))for(const r of t)"title"in r&&"url"in r&&e.push(`- ${r.title}: ${r.url}`);return e.length>0?e.join("\n"):null}static construct_message(t,r){const i="lib-wrapper.error",n=`${i}.external`,a=r.title,s=r.type_i18n;let o=c.format(`${n}.notification`,{title:a,type:s}),l=c.format(`${n}.message`,{title:a,type:s});if(!r.compatible_with_core){const t=function(t=!0){const r=game?.release?.display??game?.version??game?.data?.version??null;if(!t&&null===r)throw new e.internal("Unable to obtain the Foundry display version");return r}(!0);if(t){const e=` ${c.format(`${n}.likely-not-updated`,{type:s,version:t})}`;o+=e,l+=e}}let p=`${l}\n\n${c.localize(`${i}.not-lw`)}\n\n`;const d=r.url;"string"==typeof d&&(p+=c.format(`${n}.info`,{type:s,url:d}));const u=r.bugs;if("string"==typeof u)p+="\n",p+=c.format(`${n}.report`,{url:u});else{const e=this.get_community_support_message();e&&(p+="\n\n",p+=c.localize(`${i}.community-support`),p+="\n",p+=e)}return p+="\n\n",p+=c.localize(`${i}.tech-details`),p+=`\nDetected by libWrapper.\nPackage ID= ${r.logId}\nError= ${t}\n`,[o,p]}constructor(e,t,...r){t?t?.constructor!==f&&(t=new f(t)):t=new f;const[i,n]=T.construct_message(e,t);super(i,n,...r),this.package_info=t}get package_id(){return this.package_info?.id}}Object.freeze(T),e.package=T;class j{static init(){this.NOTIFICATION_SET=new Set,Object.seal(this)}static get ui_notifications_enabled(){try{if(function(e=!1){const t=game?.user?.isGM;if(void 0!==t)return t;const r=l(e);return r?4===r.role:null}()){if(!game?.settings?.get(t,"notify-issues-gm"))return!1}else if(!game?.settings?.get(t,"notify-issues-player"))return!1}catch(e){return console.error("libWrapper: Could not decide whether to show notifications or not. Defaulting to 'yes'.\n",e),!0}return!0}static _ui(e,t,r){if(!this.ui_notifications_enabled)return;if(this.NOTIFICATION_SET.has(e))return;this.NOTIFICATION_SET.add(e);let i=globalThis?.ui?.notifications;i&&i[t].call(i,r?`libWrapper: ${e}`:e,{permanent:"error"==t})}static ui(e,t="error",r=!0){globalThis.game?.ready?this._ui(e,t,r):Hooks.once("ready",this._ui.bind(this,e,t))}static console_ui(e,t,r="error",...i){console[r].call(console,`libWrapper: ${e}\n${t}`,...i),this.ui(`${e} ${c.localize("lib-wrapper.error.see-js-console")}`,r)}static conflict(e,t,r,i){let n;n=Array.isArray(t)?t.length>1?`[${t.map((e=>e.type_plus_title_i18n)).join(", ")}]`:t[0].type_plus_title_i18n:t.type_plus_title_i18n;const a={main:e.type_plus_title_i18n,other:n};this.console_ui(r?c.format("lib-wrapper.error.conflict.potential",a):c.format("lib-wrapper.error.conflict.confirmed",a),i,r?"warn":"error")}}y(j);class P{static _collect_stats(){try{return function(e,t=!1){const r=game?.user?.can;if(r)return r(e);const i=l(t);if(!i)return null;if(4===i.role)return!0;if(e in i.permissions)return i.permissions[e];const n=game.data.settings.find((e=>"core.permissions"===e.key));if(n?.value){const t=JSON.parse(n.value)[e];if(t&&t.includes(i.role))return!0}return!1}("SETTINGS_MODIFY")}catch(e){return j.console_ui("A non-critical error occurred while initializing libWrapper.","Could not read user permissions during initialization.\n","warn",e),!0}}static init(){this.collect_stats=this._collect_stats(),this.collect_stats&&(this.PACKAGES=new Set,this.CONFLICTS=new Map,Object.seal(this))}static register_package(e){this.collect_stats&&e.id!=t&&this.PACKAGES.add(e.key)}static register_conflict(e,t,r,i){if(!this.collect_stats)return;const n=`${e.key}/${t.key}`;let a=this.CONFLICTS.get(n);a||(a={count:0,ignored:0,package_info:e,other_info:t,targets:new Map},this.CONFLICTS.set(n,a));const s=r.name;let o=a.targets.get(s);o||(o={count:0,ignored:0},a.targets.set(s,o)),i?(a.ignored++,o.ignored++):(a.count++,o.count++)}static get conflicts(){return this.CONFLICTS}static get packages(){return this.PACKAGES}}class I{constructor(e,t,r){this.ignore_infos=new Set(e.map((e=>e.key))),this.targets=new Set(t),this.ignore_errors=r,Object.seal(this)}is_ignored(e,t,r){if(!r&&!this.ignore_errors)return!1;if(!this.ignore_infos.has(e.key))return!1;return void 0!==t.names.find((e=>this.targets.has(e)))}}class R{static init(){this.IGNORED=new Map,Object.seal(this)}static register_ignore(e,t,r,i){const n=new I(t,r,i),a=e.key;let s=this.IGNORED.get(a);s||(s=[],this.IGNORED.set(a,s)),s.push(n)}static clear_ignores(){this.IGNORED.clear()}static _is_ignored_oneway(e,t,r,i){const n=e.key,a=this.IGNORED.get(n);if(!a)return!1;for(const e of a)if(e.is_ignored(t,r,i))return!0;return!1}static _is_ignored(e,t,r,i){return this._is_ignored_oneway(e,t,r,i)||this._is_ignored_oneway(t,e,r,i)}static register_conflict(t,i,n,a,s){if(!i)return!1;if(Array.isArray(i)){let e=!1;return i.forEach((r=>{e|=this.register_conflict(t,r,n,a,s)})),e}if(t.constructor!==f)throw new e.internal(`LibWrapperConflicts.register_conflict: 'package_info' must be a PackageInfo object, but got '${t}'.`);if(i.constructor!==f)throw new e.internal(`LibWrapperConflicts.register_conflict: 'other_info' must be a PackageInfo object, but got '${i}'.`);if(null!=a&&"string"!=typeof a)throw new e.internal(`LibWrapperConflicts.register_conflict: 'target' must be a string, or null, but got '${a}'.`);if("boolean"!=typeof s)throw new e.internal(`LibWrapperConflicts.register_conflict: 'is_warning' must be a boolean, but got '${s}'.`);let o=!1;return!o&&this._is_ignored(t,i,n,s)&&(o=!0,r&&console.debug(`Conflict between ${t.type_plus_id} and ${i.type_plus_id} over '${n.name}' ignored through 'ignore_conflicts' API.`)),o||!1!==Hooks.call("libWrapper.ConflictDetected",t.id,i.id,a,n.frozen_names)||(o=!0,r&&console.debug(`Conflict between ${t.type_plus_id} and ${i.type_plus_id} over '${n.name}' ignored, as 'libWrapper.ConflictDetected' hook returned false.`)),P.register_conflict(t,i,n,o),!o}}class N extends z{static construct_message(e,t,r){const i="lib-wrapper.error",n=`${i}.conflict`,a=e.type_plus_title_i18n,s=a.charAt(0).toUpperCase()+a.slice(1),o=t.type_plus_title_i18n,l=o.charAt(0).toUpperCase()+o.slice(1),p=c.format(`${n}.confirmed`,{main:a,other:o});let d=`libWrapper: ${p}`,u=`${p}\n\n${c.localize(`${i}.not-lw`)}\n\n`,h="";const g=e.url;"string"==typeof g&&(h+=`\n- ${s}: ${g}`);const f=t.url;"string"==typeof f&&(h+=`\n- ${l}: ${f}`),h&&(u+=`${c.localize(`${n}.info`)}${h}\n\n`);let _="";const w=e.bugs;"string"==typeof w&&(_+=`\n- ${s}: ${w}`);const m=t.bugs;"string"==typeof m&&(_+=`\n- ${l}: ${m}`),_&&(u+=`${c.localize(`${n}.report`)}${_}\n\n`);const y=T.get_community_support_message();return y&&(u+=c.localize(`${i}.community-support`),u+="\n",u+=y,u+="\n\n"),u+=c.localize(`${i}.tech-details`),u+=`\nDetected by libWrapper.\nPackage IDs= ${e.logId}, ${t.logId}\nError= ${r}\n`,[d,u]}constructor(e,t,r,i,...n){e?.constructor!==f&&(e=new f(e)),t?.constructor!==f&&(t=new f(t));const[a,s]=N.construct_message(e,t,`Failed to wrap '${i}' for ${e.type_plus_id} with type OVERRIDE. An OVERRIDE wrapper for the same method has already been registered by ${t.type_plus_id}.`);super(a,s,...n),this.package_info=e,this.conflicting_info=t,this.target=i,this._wrapper=r}get package_id(){return this.package_info?.id}get module(){return this.package_id}get conflicting_id(){return this.conflicting_info?.id}get conflicting_module(){return this.conflicting_id}onUnhandled(){super.onUnhandled(),R.register_conflict(this.package_info,this.conflicting_info,this._wrapper,this.target,!1)}}Object.freeze(N),e.already_overridden=N;class S extends T{constructor(e,t,r,...i){t?.constructor!==f&&(t=new f(t)),super(r,t,...i),this._wrapper=e}}Object.freeze(S),e.invalid_chain=S,Error.stackTraceLimit=1/0;const D=function(e){try{if(!k(e))return;e instanceof z&&function(e){e.ui_msg&&e.notification_fn&&j.ui(`${e.ui_msg} ${c.localize("lib-wrapper.error.see-js-console")}`,e.notification_fn,!1),e.onUnhandled&&e.onUnhandled.apply(e)}(e),function(e){W(e)}(e)}catch(e){console.warn("libWrapper: Exception thrown while processing an unhandled error.",e)}},C=function(e){try{const t=e.reason??e.error??e;return D(t)}catch(e){console.warn("libWrapper: Exception thrown while processing an unhandled error event.",e)}};const U="1.10.8.0",x=1,L=10,M=8,F=0,G="",V="831eb8e669d14bfdd9bc4775ac88eac143674ddf",H="1.10.8.0 (831eb8e)",Y=function(e,t=0,r=0,i=0){return x==e?L==t?M==r?F==i:M>=r:L>t:x>e},K=n("WrapperType",{WRAPPER:1,MIXED:2,OVERRIDE:3}),q=n("PerformanceMode",{NORMAL:1,AUTO:2,FAST:3});class B{get name(){return this.names[0]}get frozen_names(){return Object.freeze(this.names),this.names}_add_name(e){this.names.includes(e)||(Object.isFrozen(this.names)&&(this.names=this.names.slice()),this.names.push(e))}_callstack_name(e,t=this.name){return m(t,e)}constructor(t,r,i,n){this.fn_name=r,this.object=t;let a=Object.getOwnPropertyDescriptor(t,r);if(a){if(a.get?._lib_wrapper){const t=a.get?._lib_wrapper;if(!(t instanceof this.constructor))throw new e.internal(`libWrapper: '${i}' cannot be wrapped, the descriptor already has a wrapper, but of an unexpected class ('${t.constructor.name}' vs '${this.constructor.name}').`);return t._add_name(i),t}if(!1===a.configurable)throw new e.package(`libWrapper: '${i}' cannot be wrapped, the corresponding descriptor has 'configurable=false'.`,n);a.get?(this.is_property=!0,this._wrapped_getter=a.get,this._wrapped_setter=a.set):(this.is_property=!1,this._wrapped=a.value)}else{if(a=this._get_inherited_descriptor(),!a)throw new e.package(`libWrapper: Can't wrap '${i}', target does not exist or could not be found.`,n);const t=a.get?._lib_wrapper;t?this.is_property=t.is_property:a.get??a.set?this.is_property=!0:this.is_property=!1}this.names=[],this.getter_data=[],this._getter_data_id=0,this.is_property&&(this.setter_data=[],this._setter_data_id=0),this.active=!1,this._outstanding_wrappers=0,this._current_handler_id=0,this.is_property||(this._pending_wrapped_calls=[],this._pending_wrapped_calls_cnt=0),this.update_use_static_dispatch(),i||(i=r),this._add_name(i),this._wrap()}_get_handler(){const e=this._current_handler_id;if(e===this._cached_handler_id)return this._cached_handler;const t=this,r=this._callstack_name(e),i=this._wrapped??null,n={[r]:function(...r){const n=t.use_static_dispatch;return t.should_skip_wrappers(this,e,n)?t.get_wrapped(this,!1,i).apply(this,r):n?t.get_static_dispatch_chain(this).apply(this,r):t.call_wrapper(null,this,...r)},toString:function(){return"/* WARNING: libWrapper wrappers present! */\n"+t.get_wrapped(this).toString()}},a=n[r];return a.toString=n.toString,this._cached_handler=a,this._cached_handler_id=e,a}get_static_dispatch_chain(e){const t=this._getter_data_id;let r=null;if(t===this._cached_static_dispatch_chain_id&&e===this._cached_static_dispatch_chain_obj)r=this._cached_static_dispatch_chain;else{const i=()=>{r=this.call_wrapped.bind(this,null,e)},n=this.get_fn_data(!1);for(let t=n.length-1;t>=0;t--){const a=n[t],s=a.fn;a.chain?(r||i(),r=s.bind(e,r)):r=s.bind(e)}r||i(),this._cached_static_dispatch_chain_obj=e,this._cached_static_dispatch_chain_id=t,this._cached_static_dispatch_chain=r}return r}should_skip_wrappers(t,r,i){if(r==this._current_handler_id)return!1;if(r>this._current_handler_id)throw new e.internal(`Unreachable: handler_id=${r} > this._current_handler_id=${this._current_handler_id}`);if(!this.is_property){if(this._pending_wrapped_calls_cnt<=0)return!1;if(!i){if(this._pending_wrapped_calls.indexOf(t)<0)return!1}}return!0}skip_existing_handlers(){this._current_handler_id++}_calc_use_static_dispatch(){const e=this.get_fn_data(!1);let r;for(const t of e)if(t.perf_mode)if(void 0===r)r=t.perf_mode;else if(r!==t.perf_mode){r=q.AUTO;break}return r===q.FAST||r!==q.SAFE&&!!game?.settings?.get(t,"high-performance-mode")}update_use_static_dispatch(){this.use_static_dispatch=this._calc_use_static_dispatch()}_wrap(){if(this.active)return;const e=this._callstack_name("getter"),t=this._callstack_name("setter");let r;if(this.is_property){const i=this;r={[e]:function(...e){return i.call_wrapper(null,this,...e)},[t]:function(...e){return i.call_wrapper({setter:!0},this,...e)}}}else{const i=this;r={[e]:()=>i._get_handler(),[t]:function(e){return i.set_nonproperty(e,this)}}}const i=r[e],n=r[t];i._lib_wrapper=this,Object.defineProperty(this.object,this.fn_name,{get:i,set:n,configurable:false}),this.active=!0,console.debug(`libWrapper: Wrapped '${this.name}'.`)}unwrap(){if(this.active)throw new e.internal("libWrapper: Cannot unwrap when PROPERTIES_CONFIGURABLE==false")}_get_inherited_descriptor(){let e=Object.getPrototypeOf(this.object);for(;e;){const t=Object.getOwnPropertyDescriptor(e,this.fn_name);if(t)return t;e=Object.getPrototypeOf(e)}return null}get_wrapped(t,r=!1,i){let n;if(n=void 0!==i?i:this.is_property?r?this._wrapped_setter:this._wrapped_getter:this._wrapped,null===n&&(n=void 0),void 0===n){const i=this._get_inherited_descriptor();if(i)if(this.is_property){if(!i.get&&!i.set)throw new e.internal("This wrapper is set up to wrap a property, but the inherited descriptor is a method.");n=r?i.set:i.get}else n=i.value??i.get.apply(t)}return void 0===n&&console.warn(`libWrapper: There is no wrapped method for '${this.name}', returning 'undefined'.`),n}call_wrapped(e,t,...r){e&&this._call_wrapper_update_state(e);const i=e?.setter??!1,n=!!e;let a,s;this.is_property||(this._pending_wrapped_calls_cnt++,n&&(a=t,this._pending_wrapped_calls.push(a)));try{s=this.get_wrapped(this.object,i)?.apply(t,r)}catch(e){throw this.is_property||this._cleanup_call_wrapped(a,n),e}return this.is_property||("function"==typeof s?.then?s=s.then((e=>(this._cleanup_call_wrapped(a,n),e)),(e=>{throw this._cleanup_call_wrapped(a,n),e})):this._cleanup_call_wrapped(a,n)),s}_cleanup_call_wrapped(t,r){if(!this._pending_wrapped_calls_cnt)throw new e.internal(`this._pending_wrapped_calls_cnt=${this._pending_wrapped_calls_cnt} should be unreachable at this point.`);if(this._pending_wrapped_calls_cnt--,r){const r=this._pending_wrapped_calls.indexOf(t);if(r<0)throw new e.internal("Could not find 'pend' inside 'this._pending_wrapped_calls'.");this._pending_wrapped_calls.splice(r,1)}}call_wrapper(t,r,...i){t&&this._call_wrapper_update_state(t);const n=t?.index??0,a=t?.setter??!1,s=t?.fn_data??this.get_fn_data(a),o=s[n];if(!o){if(s.length>0)throw new e.internal(`Must not have 'data===${o}' when 'fn_data.length==${s.length}'.`);return this.call_wrapped(null,r,...i)}const c=o.fn;if(!o.chain)return c.apply(r,i);const l=n+1,p=l>=s.length,d={index:l,called:!1,valid:!0,setter:a,prev_data:o,fn_data:s},u=p?this.call_wrapped.bind(this,d,r):this.call_wrapper.bind(this,d,r);let h;this._outstanding_wrappers++;try{h=c.call(r,u,...i)}catch(e){return this._cleanup_call_wrapper_thrown(d,e)}return h="function"==typeof h?.then?h.then((e=>this._cleanup_call_wrapper(e,d,o,s,u,r,i)),(e=>this._cleanup_call_wrapper_thrown(d,e))):this._cleanup_call_wrapper(h,d,o,s,u,r,i),h}_call_wrapper_update_state(t){if("valid"in t&&!t.valid)throw new e.invalid_chain(this,t.prev_data?.package_info,`This wrapper function for '${this.name}' is no longer valid, and must not be called.`);t.called=!0}_invalidate_state(t){if(t.valid=!1,this._outstanding_wrappers--,this._outstanding_wrappers<0)throw new e.internal(`Outstanding wrappers = ${this._outstanding_wrappers}, should never fall below 0.`)}_cleanup_call_wrapper_thrown(e,t){throw this._invalidate_state(e),t}_cleanup_call_wrapper(t,r,i,n,a,s,o){try{if(!r.called){let c=!i.warned_conflict||P.collect_stats,l=null,p=!1,d=!1;if(c&&(l=n.slice(r.index).filter((e=>!e.package_info.equals(i.package_info))).map((e=>e.package_info)),p=0==l.length,p||(d=R.register_conflict(i.package_info,l,this,null,!0))),i.type===K.WRAPPER){const r=new e.package(`The wrapper for '${i.target}' registered by ${i.package_info.type_plus_id} with type WRAPPER did not chain the call to the next wrapper, which breaks a libWrapper API requirement. This wrapper will be unregistered.`,i.package_info);D(r),console.error(r),globalThis.libWrapper.unregister(i.package_info.id,i.target),p||(t=a.apply(s,o))}else d&&!i.warned_conflict&&(j.conflict(i.package_info,l,!0,`${i.package_info.type_plus_id_capitalized} did not chain the wrapper for '${i.target}'.`),i.warned_conflict=!0)}}finally{this._invalidate_state(r)}return t}set_nonproperty(t,r=null){if(this.is_property)throw new e.internal("Must not call 'set_nonproperty' for a property wrapper.");r!==this.object?Object.defineProperty(r,this.fn_name,{value:t,configurable:!0,enumerable:!0,writable:!0}):(this._wrapped=t,this.skip_existing_handlers(),this.warn_classic_wrapper())}get_affected_packages(){return this.getter_data.map((e=>e.package_info))}warn_classic_wrapper(){const e=new f,t=this.get_affected_packages();if(t.length>0){R.register_conflict(e,t,this,null,!0)&&(j.conflict(e,t,!0,`Detected non-libWrapper wrapping of '${this.name}' by ${e.type_plus_id}. This will potentially lead to conflicts.`),r&&console.trace&&console.trace())}this.detected_classic_wrapper||(this.detected_classic_wrapper=[]),this.detected_classic_wrapper.push(e.key)}get_fn_data(t,r=!1){if(t&&!this.is_property)throw new e.internal(`libWrapper: '${this.name}' does not wrap a property, thus setter=true is illegal.`);const i=t?"setter_data":"getter_data";let n=this[i];return r&&(this._outstanding_wrappers>0&&(n=this[i].slice(0),this[i]=n),this[`_${i}_id`]++),n}_post_update_fn_data(){this.update_use_static_dispatch()}sort(){for(let e of[!1,!0]){if(e&&!this.is_property)continue;this.get_fn_data(e).sort(((e,t)=>e.type.value-t.type.value||t.priority-e.priority))}}add(e){const t=e.fn;t.name&&"anonymous"!==t.name||w(t,this._callstack_name(e.package_info.id??"<unknown>"));this.get_fn_data(e.setter,!0).splice(0,0,e),this.sort(e.setter),this._post_update_fn_data()}remove(e){const t=this.get_fn_data(e.setter,!0),r=t.indexOf(e);t.splice(r,1),this._post_update_fn_data()}clear(){this.getter_data=[],this.is_property&&(this.setter_data=[]),this._post_update_fn_data()}is_empty(){return!this.getter_data.length&&!this.setter_data?.length}}y(B),Object.freeze(B);const X=new Map,Z=function(e=null){X.clear();const r=e??game?.settings?.get(t,"module-priorities");if(r)for(let e of["prioritized","deprioritized"]){const t=r[e];if(!t)continue;const i="prioritized"==e?1e4:-1e4;Object.entries(t).forEach((e=>{let[t,r]=e;r.id||(r=new f(t,p.MODULE),t=r.key),X.has(t)||X.set(t,i-r.index)}))}};class J extends FormApplication{static init(){game.settings.register(t,"notify-issues-gm",{name:"lib-wrapper.settings.notify-issues-gm.name",hint:"lib-wrapper.settings.notify-issues-gm.hint",default:!0,type:Boolean,scope:"world",config:!0}),game.settings.register(t,"notify-issues-player",{name:"lib-wrapper.settings.notify-issues-player.name",hint:"lib-wrapper.settings.notify-issues-player.hint",default:!1,type:Boolean,scope:"world",config:!0}),game.settings.register(t,"high-performance-mode",{name:"lib-wrapper.settings.high-performance-mode.name",hint:"lib-wrapper.settings.high-performance-mode.hint",default:!1,type:Boolean,scope:"world",config:!0}),game.settings.registerMenu(t,"menu",{name:"",label:"lib-wrapper.settings.menu.title",icon:"fas fa-cog",type:J,restricted:!0}),game.settings.register(t,"module-priorities",{name:"",default:{},type:Object,scope:"world",config:!1,onChange:e=>Z()}),this.show_ignored_conflicts=!1,Z(),Object.seal(this)}static get defaultOptions(){return{...super.defaultOptions,template:"modules/lib-wrapper/templates/settings.html",height:700,title:c.localize("lib-wrapper.settings.menu.title"),width:600,classes:[t,"settings"],tabs:[{navSelector:".tabs",contentSelector:"form",initial:"name"}],submitOnClose:!1,closeOnSubmit:!1}}constructor(e={},t){super(e,t)}static showYesNoDialog(e,t){new Dialog({content:e,buttons:{yes:{icon:'<i class="fas fa-check"></i>',label:c.localize("lib-wrapper.settings.yes"),callback:t},no:{icon:'<i class="fas fa-times"></i>',label:c.localize("lib-wrapper.settings.no")}}}).render(!0)}getActiveWrappers(){let e=[];return b.forEach((r=>{for(let i of[!1,!0]){if(i&&!r.is_property)continue;let n=r.name;i&&(n=`${n}#set`);let a={name:n,packages:[]};r.get_fn_data(i).forEach((e=>{if(e.package_info.id==t)return;const r={name:e.package_info.settingsName,type:e.type.name,perf_mode:e.perf_mode.name};"AUTO"==r.perf_mode?r.perf_mode=null:r.perf_mode=`, ${r.perf_mode}`,a.packages.push(r)})),r.detected_classic_wrapper&&r.detected_classic_wrapper.forEach((e=>{a.packages.push({name:new f(e).settingsName,type:"MANUAL",perf_mode:null})})),a.packages.length>0&&e.push(a)}})),e.sort(((e,t)=>t.packages.length-e.packages.length)),e}getConflicts(){if(!P.collect_stats)return null;let e=[];return P.conflicts.forEach((t=>{let r=t.count;if(this.show_ignored_conflicts&&(r+=t.ignored),0==r)return;const i=[];e.push({count:t.count,ignored:this.show_ignored_conflicts?t.ignored:0,total:r,package_id:t.package_info.settingsName,other_id:t.other_info.settingsName,targets:i}),t.targets.forEach(((e,t)=>{let r=e.count;this.show_ignored_conflicts&&(r+=e.ignored),r>0&&i.push({target:t,count:e.count,total:r,ignored:this.show_ignored_conflicts?e.ignored:0})})),i.sort(((e,t)=>e.total-t.total))})),e.sort(((e,t)=>e.total-t.total)),e}getPackages(){let e={prioritized:[],normal:[],deprioritized:[]};const r=game.settings.get(t,"module-priorities"),i=r.prioritized??{},n=r.deprioritized??{},a=c.localize("lib-wrapper.settings.menu.priorities.package-inactive");return P.collect_stats&&(P.packages.forEach((t=>{const r=new f(t);r.key in i||r.key in n||e.normal.push(r)})),e.normal.sort(((e,t)=>e.id.localeCompare(t.id)))),Object.entries(i).forEach((t=>{let[r,i]=t;i.id||(i=new f(r,p.MODULE),r=i.key),e.prioritized.push({key:r,id:i.id,title:i.title??`${i.title} <${a}>`,index:i.index})})),e.prioritized.sort(((e,t)=>e.index-t.index)),Object.entries(n).forEach((t=>{let[r,n]=t;r in i||(n.id||(n=new f(r,p.MODULE),r=n.key),e.deprioritized.push({key:r,id:n.id,title:n.title??`${n.title} <${a}>`,index:n.index}))})),e.deprioritized.sort(((e,t)=>e.index-t.index)),e}getData(){const e=[];{const t="lib-wrapper.support-channels",r=c.localize(t);if(Array.isArray(r))for(const t of r)"title"in t&&"url"in t&&e.push(t)}return{about:{name:"libWrapper",version:H,collect_stats:P.collect_stats,translation_credits:c.localize("lib-wrapper.settings.menu.about.credits-translation"),support:e},wrappers:this.getActiveWrappers(),conflicts:this.getConflicts(),packages:this.getPackages(),show_ignored_conflicts:this.show_ignored_conflicts}}activateListeners(e){super.activateListeners(e);let t=this;e.find(".caret.has-nested").on("click",(function(e){const t=$(this);t.parent().find(".nested").toggleClass("active"),t.toggleClass("caret-down")})),e.find("button.reload").on("click",(function(e){t.render(!0)})),e.find(".lw-show-ignored-conflicts").on("change",(function(e){const r=$(this).find("input[type=checkbox]").prop("checked");t.show_ignored_conflicts=r,t.render(!0)})),e.find(".package-priority-group").on("click",(function(e){const t=$(this).find("select");t.is(":focus")||t.focus()})),e.find("button.change-priority").on("click",(function(t){const r=$(this),i=r.data("which"),n="up"===r.data("direction"),a=e.find(`.${i}`).find("option:selected"),s=n?a.prev():a.next();s.length&&(n?s.before(a):s.after(a))})),e.find("button.change-category").on("click",(function(t){const r=$(this),i=r.data("from"),n=r.data("to"),a=e.find(`.${i}`),s=e.find(`.${n}`),o=a.find("option:selected");let c=o.next();if(0==c.length&&(c=o.prev()),s.append(o),"packages-normal"==n){const e=s.find("option");e.sort(((e,t)=>$(e).val()>$(t).val()?1:-1)),s.empty().append(e)}c.length&&a.val(c.val()),a.focus()})),e.find(".submit").on("click",(function(t){for(let t of["packages-prioritized","packages-deprioritized"]){const r=e.find(`.${t}`).find("option");let i=[];r.each(((e,t)=>{i.push($(t).val())})),$("<input>").attr("type","hidden").attr("name",`${t}-hidden`).attr("value",i.join(",")).appendTo(e)}e.submit()})),e.find(".reset").on("click",(function(t){$("input[type=hidden]").remove(),J.showYesNoDialog(`<p>${c.localize("lib-wrapper.settings.menu.warning-reset-priorities")}</p>`,(()=>{for(let t of["packages-prioritized","packages-deprioritized"])$("<input>").attr("type","hidden").attr("name",`${t}-hidden`).attr("value","").appendTo(e);e.submit()}))}))}async _updateObject(e,r){const i=game.settings.get(t,"module-priorities");for(let e of["prioritized","deprioritized"]){const t=`packages-${e}-hidden`;if(!(t in r))continue;const n=r[t],a=""===n?[]:n.split(",");let s=i[e]??{},o={},c=0;a.forEach((e=>{if(!e)return;const t=s[e],r=new f(e);o[e]={id:r.id,title:r.exists?r.title:t.title,index:c++}})),i[e]=o}Object.keys(i.deprioritized).forEach((e=>{e in i.prioritized&&delete i.deprioritized[e]})),await game.settings.set(t,"module-priorities",i),this.render(!0),J.showYesNoDialog(`<p>${c.localize("lib-wrapper.settings.menu.warning-save")}</p>`,(()=>location.reload()))}}let Q=!1,ee=!0;const te=new RegExp(["(","[^.[]+","|","\\[","(","'","(","[^'\\\\]","|","\\\\.",")+?","'","|",'"',"(",'[^"\\\\]',"|","\\\\.",")+?",'"',")","\\]",")"].join(""),"g"),re=new RegExp(["(","^\\['","|","'\\]$","|",'^\\["',"|",'"\\]$',")"].join(""),"g");function ie(e){let t=e.endsWith("#set");return[t?e.slice(0,-4):e,t]}function ne(e){return/^[a-zA-Z_$][0-9a-zA-Z_$]*?([.[]|$)/.test(e)}function ae(t,r){const i=ie(t)[0];if(!ne(i))throw new e.package(`Invalid target '${i}'.`,r);const n=i.match(te).map((e=>e.replace(/\\(.)/g,"$1").replace(re,""))),a=n.splice(0,1)[0];if(!/^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(a))throw new e.package(`Invalid target '${i}': Invalid root scope '${a}'.`,r);if("libWrapper"==a)throw new e.package("Not allowed to wrap libWrapper internals.",r);let s,o;if(0==n.length){if(!(a in globalThis))throw new e.package(`Could not find target '${i}': Could not find scope 'globalThis.${a}'.`,r);o=a,s=globalThis}else{o=n.pop();const t=function(e){try{return globalThis[e]??_(e)}catch(e){return}}(a);if(!t)throw new e.package(`Could not find target '${i}': Could not find root scope '${a}'.`,r);s=t;for(const t of n)if(s=s[t],!s)throw new e.package(`Could not find target '${i}': Could not find scope '${t}'.`,r)}return[s,o,i]}function se(e,t=null){return function(e,t,r,i){const n=new B(e,t,r,i);return b.add(n),n}(...ae(e,t),t)}function oe(e,t,r){return t.get_fn_data(r).find((t=>t.package_info?.equals(e)))}function ce(e,t){const r=ie(t),i=r[0],n=r[1],a=function(e){const t=ie(e)[0];for(let e of b)if(e.names.includes(t))return e;return null}(i);return a?oe(e,a,n):null}function le(t,r,i){const n=ce(t,r);if(!n){if(i)throw new e.package(`Cannot unregister '${r}' by ${t.type_plus_id} as no such wrapper has been registered`,t);return}const a=n.wrapper;a.remove(n),function(e){e.is_empty()}(a)}function pe(r){let i=new f;if(!f.is_valid_id(r))throw new e.package("Parameter 'package_id' is invalid.",i);if(i.exists){if(r!=i.id)throw new e.package(`${i.type_plus_id_capitalized} is not allowed to call libWrapper with package_id='${r}'.`,i)}else i=new f(r);if(r==t){if(!ee)throw new e.package(`Not allowed to call libWrapper with package_id='${r}'.`,i)}else if(!i.exists&&game.modules?.size)throw new e.package(`Package '${r}' is not a valid package.`,i);return i}class de{static get version(){return U}static get versions(){return[x,L,M,F,G]}static get git_version(){return V}static get is_fallback(){return!1}static get debug(){return r}static set debug(e){r=e}static get LibWrapperError(){return e.base}static get Error(){return e.base}static get LibWrapperInternalError(){return e.internal}static get InternalError(){return e.internal}static get LibWrapperPackageError(){return e.package}static get PackageError(){return e.package}static get LibWrapperAlreadyOverriddenError(){return e.already_overridden}static get AlreadyOverriddenError(){return e.already_overridden}static get LibWrapperInvalidWrapperChainError(){return e.invalid_chain}static get InvalidWrapperChainError(){return e.invalid_chain}static get onUnhandledError(){return D}static get WRAPPER(){return K.WRAPPER}static get MIXED(){return K.MIXED}static get OVERRIDE(){return K.OVERRIDE}static get PERF_NORMAL(){return q.NORMAL}static get PERF_AUTO(){return q.AUTO}static get PERF_FAST(){return q.FAST}static get version_at_least(){return Y}static register(i,n,a,s="MIXED",o={}){const c=pe(i);if(i!=t&&!Q)throw new e.package("Not allowed to register wrappers before the 'libWrapperReady' hook fires",c);if(!n||"string"!=typeof n)throw new e.package("Parameter 'target' must be a string.",c);if(!(a&&a instanceof Function))throw new e.package("Parameter 'fn' must be a function.",c);if(null===(s=K.get(s,null)))throw new e.package(`Parameter 'type' must be one of [${K.list.join(", ")}].`,c);const l=o?.chain??s.value<K.OVERRIDE.value;if("boolean"!=typeof l)throw new e.package("Parameter 'chain' must be a boolean.",c);const p=q.get(o?.perf_mode??"AUTO",null);if(null===p)throw new e.package(`Parameter 'perf_mode' must be one of [${PERF_MODE.list.join(", ")}].`,c);const d=ie(n),u=d[0],h=d[1];let g=se(n,c);if(h&&!g.is_property)throw new e.package(`Cannot register a wrapper for '${n}' by ${c.type_plus_id}' because '${u}' is not a property, and therefore has no setter.`,c);if(oe(c,g,h))throw new e.package(`A wrapper for '${n}' has already been registered by ${c.type_plus_id}.`,c);const f=function(e,r){if(e.id===t)return Number.MAX_VALUE;const i=X.get(e.key);return void 0!==i?i:0}(c);if(c.id!=t&&P.register_package(c),s.value>=K.OVERRIDE.value){const t=g.get_fn_data(h).find((e=>e.type===K.OVERRIDE));if(t){if(f<=t.priority)throw new e.package(c,t.package_info,g,n);if(!1!==Hooks.call("libWrapper.OverrideLost",t.package_info.id,c.id,g.name,g.frozen_names)){R.register_conflict(c,t.package_info,g,null,!1)&&j.conflict(t.package_info,c,!1,`${c.type_plus_id_capitalized} has higher priority, and is replacing the 'OVERRIDE' registered by ${c.type_plus_id} for '${g.name}'.`)}}}let _={package_info:c,target:n,setter:h,fn:a,type:s,wrapper:g,priority:f,chain:l,perf_mode:p};g.add(_),(r||c.id!=t)&&(Hooks.callAll("libWrapper.Register",c.id,n,s,o),console.info(`libWrapper: Registered a wrapper for '${n}' by ${c.type_plus_id} with type ${s}.`))}static unregister(e,i,n=!0){const a=pe(e);le(a,i,n),(r||a.id!=t)&&(Hooks.callAll("libWrapper.Unregister",a.id,i),console.info(`libWrapper: Unregistered the wrapper for '${i}' by ${a.type_plus_id}.`))}static unregister_all(e){const i=pe(e);for(let e of b)this.unregister(i.id,e.name,!1),e.is_property&&this.unregister(i.id,`${e.name}#set`,!1);(r||i.id!=t)&&(Hooks.callAll("libWrapper.UnregisterAll",i.id),console.info(`libWrapper: Unregistered all wrapper functions by ${i.type_plus_id}.`))}static ignore_conflicts(i,n,a,s={}){const o=pe(i);if(!Q)throw new e.package("Not allowed to ignore conflicts before the 'libWrapperReady' hook fires",o);Array.isArray(n)||(n=[n]),Array.isArray(a)||(a=[a]);const c=e=>"string"==typeof e;if(!n.every(c))throw new e.package("Parameter 'ignore_ids' must be a string, or an array of strings.",o);if(!a.every(c))throw new e.package("Parameter 'targets' must be a string, or an array of strings.",o);if(!a.every((e=>ne(e))))throw new e.package("Parameter 'targets' must only contain valid targets.",o);const l=s.ignore_errors??!1;if("boolean"!=typeof l)throw new e.package("Parameter 'options.ignore_errors' must be a boolean.",o);const p=n.map((e=>new f(e))).filter((e=>e.exists));0!=p.length?(R.register_ignore(o,p,a,l),(r||o.id!=t)&&console.debug(`libWrapper: Ignoring conflicts involving ${o.type_plus_id} and [${p.map((e=>e.type_plus_id)).join(", ")}] for targets [${a.join(", ")}].`)):console.debug(`libWrapper: Ignoring 'ignore_conflict' call for ${o.type_plus_id} since none of the package IDs provided exist or are active.`)}}y(de),Object.freeze(de),delete globalThis.libWrapper,Object.defineProperty(globalThis,"libWrapper",{get:()=>de,set:t=>{throw new e.package("Not allowed to re-assign the global instance of libWrapper")},configurable:!1}),globalThis.addEventListener("error",C),globalThis.addEventListener("unhandledrejection",C),Hooks.onError?function(){try{libWrapper.register("lib-wrapper","Hooks.onError",(function(e,...t){const r=t[1];return D(r),e(...t)}),"WRAPPER",{perf_mode:"FAST"})}catch(e){j.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Hooks.onError' wrapper.\n","warn",e)}}():function(){try{const e="() => function "+Hooks._call.toString(),t=e.replace(/catch[\s\n]*\((.*)\)[\s\n]*{/gim,"$& globalThis.libWrapper.onUnhandledError($1);");if(e===t)throw new Error(`Could not patch 'Hooks._call' method:\n${e}`);r&&console.log(`Patched Hooks._call: ${t}`);const i=_(t)?.();if("function"!=typeof i)throw new Error(`Evaluation of patched 'Hooks._call' method did not return a function:\nPatched Method: ${t}\nReturned: ${i}`);Hooks._call=i}catch(e){j.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Hooks._call' wrapper.\n","warn",e)}try{libWrapper.register("lib-wrapper","Application.prototype._render",(function(e,...t){return e(...t).catch((e=>{throw D(e),e}))}),"WRAPPER",{perf_mode:"FAST"})}catch(e){j.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Application.prototype._render' wrapper.\n","warn",e)}}();{const t=m("libWrapperInit"),r={[t]:async function(e,...t){{const e=new f("lib-wrapper",p.MODULE);le(e,"Game.toString",!0),le(e,"Game.prototype.initialize",!0)}return Q=!0,await c.init(),J.init(),P.init(),R.init(),j.init(),console.info(`libWrapper ${H}: Ready.`),Hooks.callAll("libWrapper.Ready",de),e(...t)}};de.register("lib-wrapper","Game.prototype.initialize",r[t],de.WRAPPER,{perf_mode:de.PERF_FAST}),de.register("lib-wrapper","Game.toString",(function(){throw new e.package("Using 'Game.toString()' before libWrapper initialises is not allowed for compatibility reasons.")}),de.WRAPPER,{perf_mode:de.PERF_FAST}),Hooks.once("init",(()=>{if(!Q)throw new e.internal("Could not successfuly initialise libWrapper, likely due to a compatibility issue with another module.")}))}ee=!1;//# sourceMappingURL=lib-wrapper.js.map
